/*
 * Copyright 2016-2020, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *
 *     * Neither the name of the copyright holder nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * patcher.c -- patching a library
 *
 * Jumping from the subject library:
 *
 *     /--------------------------\
 *     |               subject.so |
 *     |                          |
 *     |  jmp to_trampoline_table |  patched by activate_patches()
 *  /->|   |                      |
 *  |  \___|______________________/
 *  |      |
 *  |  /---|--------------------------\
 *  |  | movabs %r11, wrapper_address | jmp generated by activate_patches()
 *  |  | jmp *%r11                    | This allows subject.so and
 *  |  |   |                          | libsyscall_intercept.so to be farther
 *  |  \___|__________________________/ than 2 gigabytes from each other
 *  |      |
 *  |  /---|-----------------------------\
 *  |  |   |  libsyscall_intercept.so    |
 *  |  |   |                             |
 *  |  | /-|--------------------------\  |
 *  |  | | |  static unsigned char    |  |
 *  |  | | |  asm_wrapper_space[]     |  |
 *  |  | | |    in BSS                |  | wrapper routine
 *  |  | | |                          |  | generated into asm_wrapper_space
 *  |  | | |                          |  | by create_wrapper()
 *  |  | |wrapper routine             |  |
 *  |  | |calls C hook function  ----------> intercept_routine in intercept.c
 *  |  | |movabs %r11, return_address |  |
 *  |  | |jmp *%r11                   |  |
 *  |  | \_|__________________________/  |
 *  |  \___|_____________________________/
 *  |      |
 *  \______/
 *
 */

#include "intercept.h"
#include "intercept_util.h"
#include "intercept_log.h"

#include <assert.h>
#include <stdint.h>
#include <syscall.h>
#include <sys/mman.h>
#include <string.h>

#include <stdio.h>

#define LONG_JUMP_SIZE 8  // 4 bytes for auipc + 4 bytes for jalr

#if HAS_RISCV_VECTOR
	#include <riscv_vector.h>
	static bool has_vector_extension(){
		return true;
	}
#else
	static bool has_vector_extension(){
		return false;
	}
#endif

/* The size of surrounding instruction(s) + ecall */
enum { SYSCALL_PATCH_SIZE = 4 + 4 };

bool patchable_syscalls[MAX_SYSCALLS+1] = {false};
extern char* get_syscall_name(int sys_num);

static void create_wrapper(struct patch_desc *patch, unsigned char **dst);

/*
 * create_absolute_jump(from, to)
 * Create an indirect jump using the auipc and jalr instructions.
 *
 * auipc a7, offset[31:12]
 * jalr x0, offset[11:0](a7)
 *
 * This uses up 8 bytes for the jump instructions. The offset is calculated
 * relative to the position of the instructions and is split between the
 * auipc and jalr instructions. If the destination address is a negative
 * offset, the two's complement of the offset is used.
 */

static unsigned char *
create_absolute_jump(unsigned char *from, unsigned char *to, uint32_t reg_bits, uint32_t return_address_reg)
{
    // Calculate the delta, considering the instruction size (8 bytes)
    ptrdiff_t delta = ((unsigned char *)to) - (from + LONG_JUMP_SIZE);

    if (delta > ((ptrdiff_t)INT32_MAX) || delta < ((ptrdiff_t)INT32_MIN))
        xabort("Destination not in range");

    // Calculate the upper 20 bits for the auipc instruction
    int32_t delta_upper = (delta + (1 << 11)) >> 12; // Add 0x800 (2048) to round up if necessary
    int32_t delta_lower = (delta & 0xfff) + 8; // Lower 12 bits for jalr

    // Generate the auipc instruction
    uint32_t auipc = 0x00000017 | (delta_upper << 12) | (reg_bits << 7); // opcode for auipc is 0x17, reg_bits shifted to rd position

    // Determine the register to store the return address
    uint32_t ra_reg_bits = return_address_reg; // Use x0 if NULL, otherwise use provided reg

	// funct3 for JALR instruction
    uint32_t funct3 = 0x0 << 12;

    // Generate the jalr instruction using the specified register
    uint32_t jalr = 0x00000067 | funct3 | (delta_lower << 20) | (reg_bits << 15) | (ra_reg_bits << 7); // jalr with custom register

	// debug_dump("Generated JALR instruction: 0x%08x\n", jalr);

    // Write the instructions to memory
    unsigned char *auipc_bytes = (unsigned char *)&auipc;
    unsigned char *jalr_bytes = (unsigned char *)&jalr;

    from[0] = auipc_bytes[0];
    from[1] = auipc_bytes[1];
    from[2] = auipc_bytes[2];
    from[3] = auipc_bytes[3];

    from[4] = jalr_bytes[0];
    from[5] = jalr_bytes[1];
    from[6] = jalr_bytes[2];
    from[7] = jalr_bytes[3];


    return from + 8;
}

/*
 * is_copiable_before_syscall
 * checks if an instruction found before a syscall instruction
 * can be copied (and thus overwritten).
 */
static bool
is_copiable_before_syscall(struct intercept_disasm_result ins)
{
	if (!ins.is_set)
		return false;

	return !(ins.has_ip_relative_opr ||
	    ins.is_call ||
	    ins.is_rel_jump ||
	    ins.is_jump ||
	    ins.is_ret ||
	    ins.is_syscall);
}

/*
 * is_copiable_after_syscall
 * checks if an instruction found after a syscall instruction
 * can be copied (and thus overwritten).
 *
 * Notice: we allow the copy of ret instructions.
 */
static bool
is_copiable_after_syscall(struct intercept_disasm_result ins)
{
	if (!ins.is_set)
		return false;

	return !(ins.has_ip_relative_opr ||
	    ins.is_call ||
	    ins.is_rel_jump ||
	    ins.is_jump ||
	    ins.is_endbr ||
	    ins.is_syscall);
}


/*
 * check_surrounding_instructions
 * Sets up the following members in a patch_desc, based on
 * instruction being relocateable or not:
 * uses_prev_ins ; uses_prev_ins_2 ; uses_next_ins, uses_next_ins_2
 */
static void
check_surrounding_instructions(struct intercept_desc *desc,
				struct patch_desc *patch)
{
	unsigned int total_length = 0;

	/* Check and add preceding_ins if usable */ 
	if (patch->preceding_ins.is_lea_rip ||
	    (is_copiable_before_syscall(patch->preceding_ins) &&
	    !is_overwritable_nop(&patch->preceding_ins) &&
	    !has_jump(desc, patch->syscall_addr - patch->preceding_ins.length))) {
		patch->uses_prev_ins = true;
		total_length += patch->preceding_ins.length;
	} else {
		patch->uses_prev_ins = false;
	}

	/* Check and add preceding_ins_2 only if preceding_ins is usable and total_length < 4 */
	if (patch->uses_prev_ins && total_length < 4) {
		if (patch->preceding_ins_2.is_lea_rip ||
		    (is_copiable_before_syscall(patch->preceding_ins_2) &&
		    !is_overwritable_nop(&patch->preceding_ins_2) &&
		    !has_jump(desc, patch->syscall_addr
				- patch->preceding_ins.length - patch->preceding_ins_2.length))) {
			patch->uses_prev_ins_2 = true;
			total_length += patch->preceding_ins_2.length;
		} else {
			patch->uses_prev_ins_2 = false;
		}
	} else {
		patch->uses_prev_ins_2 = false;
	}

	/* Check and add following_ins if usable and total_length < 4 */
	if (total_length < 4) {
		if (patch->following_ins.is_lea_rip ||
		    (is_copiable_after_syscall(patch->following_ins) &&
		    !is_overwritable_nop(&patch->following_ins) &&
		    !has_jump(desc, patch->syscall_addr + SYSCALL_INS_SIZE))) {
			patch->uses_next_ins = true;
			total_length += patch->following_ins.length;
		} else {
			patch->uses_next_ins = false;
		}
	} else {
		patch->uses_next_ins = false;
	}

	/* Check and add following_ins_2 only if following_ins is usable and total_length < 4 */
	if (patch->uses_next_ins && total_length < 4) {
		if (patch->following_ins_2.is_lea_rip ||
		    (is_copiable_after_syscall(patch->following_ins_2) &&
		    !is_overwritable_nop(&patch->following_ins_2) &&
		    !has_jump(desc, patch->syscall_addr + SYSCALL_INS_SIZE
			+ patch->following_ins.length))) {
			patch->uses_next_ins_2 = true;
			total_length += patch->following_ins_2.length;
		} else {
			patch->uses_next_ins_2 = false;
		}
	} else {
		patch->uses_next_ins_2 = false;
	}

	patch->is_patchable = (total_length >= SYSCALL_PATCH_SIZE - SYSCALL_INS_SIZE);

}


/*
 * create_patch_wrappers - create the custom assembly wrappers
 * around each syscall to be intercepted. Well, actually, the
 * function create_wrapper does that, so perhaps this function
 * deserves a better name.
 * What this function actually does, is figure out how to create
 * a jump instruction in libc ( which bytes to overwrite ).
 * If it successfully finds suitable bytes for hotpatching,
 * then it determines the exact bytes to overwrite, and the exact
 * address for jumping back to libc.
 *
 * This is all based on the information collected by the routine
 * find_syscalls, which does the disassembling, finding jump destinations,
 * finding padding bytes, etc..
 */
void
create_patch_wrappers(struct intercept_desc *desc, unsigned char **dst)
{
	int count = 0;

	for (unsigned patch_i = 0; patch_i < desc->count; ++patch_i) {
		struct patch_desc *patch = desc->items + patch_i;
		// debug_dump("patching %s:0x%lx syscall num: %ld\n", desc->path,
				// patch->syscall_addr - desc->base_addr,patch->syscall_num);


		/*
			* No padding space is available, so check the
			* instructions surrounding the syscall instruction.
			* If they can be relocated, then they can be
			* overwritten. Of course some instructions depend
			* on the value of the RIP register, these can not
			* be relocated.
			*/

		check_surrounding_instructions(desc, patch);
		if(patch->is_patchable == true){
			// debug_dump("syscall num: %ld\n", patch->syscall_num);
			if(patch->syscall_num >= 0 && patch->syscall_num <= MAX_SYSCALLS)
				patchable_syscalls[patch->syscall_num] = true;
			count++;
		} else{
			char buffer[0x1000];

			int l = snprintf(buffer, sizeof(buffer),
				"unintercepted syscall at: %s 0x%lx\n",
				desc->path,
				patch->syscall_offset);

			intercept_log(buffer, (size_t)l);
			continue;
		}

		/*
			* Count the number of overwritable bytes
			* in the variable length.
			* Sum up the bytes that can be overwritten.
			* The SYSCALL_INS_SIZE bytes of the syscall instruction can
			* be overwritten definitely, so length starts
			* as SYSCALL_INS_SIZE.
			*/
		unsigned length = SYSCALL_INS_SIZE;

		patch->dst_jmp_patch = patch->syscall_addr;

		/*
			* If the preceding instruction is relocatable,
			* add its length. Also, the the instruction right
			* before that.
			*/
		if (patch->uses_prev_ins) {
			length += patch->preceding_ins.length;
			patch->dst_jmp_patch -=
				patch->preceding_ins.length;

			if (patch->uses_prev_ins_2) {
				length += patch->preceding_ins_2.length;
				patch->dst_jmp_patch -=
					patch->preceding_ins_2.length;
			}
		}

		/*
			* If the following instruction is relocatable,
			* add its length. This also affects the return address.
			* Normally, the library would return to libc after
			* handling the syscall by jumping to instruction
			* right after the syscall. But if that instruction
			* is overwritten, the returning jump must jump to
			* the instruction after it.
			*/
		if (patch->uses_next_ins) {
			length += patch->following_ins.length;

			/*
				* Address of the syscall instruction
				* plus SYSCALL_INS_SIZE bytes
				* plus the length of the following instruction
				*
				* adds up to:
				*
				* the address of the second instruction after
				* the syscall.
				*/
			patch->return_address = patch->syscall_addr +
				SYSCALL_INS_SIZE +
				patch->following_ins.length;
				
			if (patch->uses_next_ins_2) {
				length += patch->following_ins_2.length;
				patch->return_address += patch->following_ins_2.length;
			}
		} else {
			/*
				* Address of the syscall instruction
				* plus SYSCALL_INS_SIZE bytes
				*
				* adds up to:
				*
				* the address of the first instruction after
				* the syscall ( just like in the case of
				* using padding bytes ).
				*/
			patch->return_address =
				patch->syscall_addr + SYSCALL_INS_SIZE;
		}
		mark_jump(desc, patch->return_address);

		// debug_dump("address: %p\n", *dst);
		create_wrapper(patch, dst);
			
	}
	int patched = 0;

	for(int i = 0;i<=MAX_SYSCALLS;i++){
		if(patchable_syscalls[i] == true){
			patched++;
		}
	}
	debug_dump("Total syscalls in RISCV: %d, Patchable: %d, Total count in libc: 511, Total patchable count in libc: %d\n",MAX_SYSCALLS,patched, count);
}

/*
 * Referencing symbols defined in intercept_template.s
 */
extern unsigned char intercept_asm_wrapper_tmpl[];
extern unsigned char intercept_asm_wrapper_tmpl_end;
extern unsigned char intercept_asm_wrapper_patch_desc_addr;
extern unsigned char intercept_asm_wrapper_wrapper_level1_addr;
extern unsigned char intercept_asm_wrapper_syscall_num;
extern unsigned char intercept_wrapper;

size_t asm_wrapper_tmpl_size;
static ptrdiff_t o_patch_desc_addr;
static ptrdiff_t o_wrapper_level1_addr;
static ptrdiff_t o_wrapper_syscall_num;

bool intercept_wrapper_must_save_simd;

/*
 * init_patcher
 * Some variables need to be initialized before patching.
 * This routine must be called once before patching any library.
 */
void
init_patcher(void)
{
	unsigned char *begin = &intercept_asm_wrapper_tmpl[0];

	assert(&intercept_asm_wrapper_tmpl_end > begin);
	assert(&intercept_asm_wrapper_patch_desc_addr > begin);
	assert(&intercept_asm_wrapper_wrapper_level1_addr > begin);
	assert(&intercept_asm_wrapper_syscall_num > begin);
	assert(&intercept_asm_wrapper_patch_desc_addr <
		&intercept_asm_wrapper_tmpl_end);
	assert(&intercept_asm_wrapper_wrapper_level1_addr <
		&intercept_asm_wrapper_tmpl_end);
	assert(&intercept_asm_wrapper_syscall_num <
		&intercept_asm_wrapper_tmpl_end);

	asm_wrapper_tmpl_size =
		(size_t)(&intercept_asm_wrapper_tmpl_end - begin);
	o_patch_desc_addr = &intercept_asm_wrapper_patch_desc_addr - begin;
	o_wrapper_level1_addr =
		&intercept_asm_wrapper_wrapper_level1_addr - begin;
	o_wrapper_syscall_num = 
		&intercept_asm_wrapper_syscall_num - begin;

	intercept_wrapper_must_save_simd = has_vector_extension();
}

static unsigned char *
create_far_load(unsigned char *from, unsigned char *to, uint32_t reg_bits)
{
    // Calculate the delta, considering the instruction size (8 bytes)
    ptrdiff_t delta = (to) - (from + LONG_JUMP_SIZE);

    // If delta exceeds the 64-bit addressable range, abort
    if (delta > ((ptrdiff_t)INT64_MAX) || delta < ((ptrdiff_t)INT64_MIN)) {
        xabort("Address not in range"); // Replace xabort with standard abort
    }

    // Calculate the upper 20 bits for the auipc instruction
    int32_t delta_upper = (delta + (1 << 11)) >> 12; // Add 0x800 (2048) to round up if necessary
    int32_t delta_lower = (delta & 0xfff) + 8; // Lower 12 bits for addi (add 8 for PC-relative offset)

    // Generate the auipc instruction
    uint32_t auipc = 0x00000017 | (delta_upper << 12) | (reg_bits << 7); // AUIPC encoding

    // Generate the addi instruction using the specified register
    uint32_t addi = 0x00000013 | (delta_lower << 20) | (reg_bits << 7) | (reg_bits << 15); // ADDI encoding

    // Write the instructions to memory
    *((uint32_t *)from) = auipc;  // Write AUIPC instruction
    *((uint32_t *)(from + 4)) = addi;  // Write ADDI instruction

    return from + 8; // Move the pointer forward by the size of two instructions
}

static unsigned char *
create_addi(unsigned char *code, int32_t syscall_num, uint32_t rd, uint32_t rs1)
{
    // Construct the ADDI instruction with the provided register bits
    uint32_t addi = (syscall_num << 20) | (rs1 << 15) | (rd << 7) | 0x13;  // 0x13 is the opcode for ADDI

    // Write the ADDI instruction to the code buffer
    *code++ = (addi >> 0) & 0xFF;
    *code++ = (addi >> 8) & 0xFF;
    *code++ = (addi >> 16) & 0xFF;
    *code++ = (addi >> 24) & 0xFF;

    // Return the updated pointer to the code buffer
    return code;
}
/*
 * relocate_instruction
 * Places an instruction equivalent to `ins` to the memory location at `dst`.
 * Only handles instructions that can be copied verbatim, and some LEA
 * instructions.
 */
static unsigned char *
relocate_instruction(unsigned char *dst,
			const struct intercept_disasm_result *ins)
{
	memcpy(dst, ins->address, ins->length);
	return dst + ins->length;
}

/*
 * create_wrapper
 * Generates an assembly wrapper. Copies the template written in
 * intercept_template.s, and generates the instructions specific
 * to a particular syscall into the new copy.
 * After this wrapper is created, a syscall can be replaced with a
 * jump to this wrapper, and wrapper is going to call dest_routine
 * (actually only after a call to mprotect_asm_wrappers).
 */
static void
create_wrapper(struct patch_desc *patch, unsigned char **dst)
{
	/* Create a new copy of the template */
	patch->asm_wrapper = *dst;

	/* Copy the previous instruction(s) */
	if (patch->uses_prev_ins) {
		if (patch->uses_prev_ins_2)
			*dst = relocate_instruction(*dst,
					&patch->preceding_ins_2);
		// debug_dump("preceding ins:%p\n",patch->preceding_ins.address);
		*dst = relocate_instruction(*dst, &patch->preceding_ins);
	}

	memcpy(*dst, intercept_asm_wrapper_tmpl, asm_wrapper_tmpl_size);

	create_far_load(*dst + o_patch_desc_addr, (unsigned char*)patch, 6);
	create_absolute_jump(*dst + o_wrapper_level1_addr, &intercept_wrapper, 6, 1);
	create_addi(*dst + o_wrapper_syscall_num, patch->syscall_num, 17, 0 );
	*dst += asm_wrapper_tmpl_size;

	/* Copy the following instruction */
	if (patch->uses_next_ins) {
		*dst = relocate_instruction(*dst, &patch->following_ins);
		if (patch->uses_next_ins_2)
			*dst = relocate_instruction(*dst,
					&patch->following_ins_2);
	}
		

	*dst = create_absolute_jump(*dst, patch->return_address, 17, 0);
}

/*
 * activate_patches()
 * Loop over all the patches, and and overwrite each syscall.
 */
void
activate_patches(struct intercept_desc *desc)
{
	unsigned char *first_page;
	size_t size;

	if (desc->count == 0)
		return;

	first_page = round_down_address(desc->text_start);
	size = (size_t)(desc->text_end - first_page);

	mprotect_no_intercept(first_page, size,
	    PROT_READ | PROT_WRITE | PROT_EXEC,
	    "mprotect PROT_READ | PROT_WRITE | PROT_EXEC");

	for (unsigned i = 0; i < desc->count; ++i) {
		const struct patch_desc *patch = desc->items + i;

		if(patch->is_patchable){
			
			if (patch->dst_jmp_patch < desc->text_start ||
					patch->dst_jmp_patch > desc->text_end)
					xabort("dst_jmp_patch outside text");

			/*
			* The dst_jmp_patch pointer contains the address where
			* the actual jump instruction escaping the patched text
			* segment should be written.
			* This is either at the place of the original syscall
			* instruction, or at some usable padding space close to
			* it (an overwritable NOP instruction).
			*/
			create_absolute_jump(
				patch->dst_jmp_patch, patch->asm_wrapper, 17, 0);
		}
	}

	mprotect_no_intercept(first_page, size,
	    PROT_READ | PROT_EXEC,
	    "mprotect PROT_READ | PROT_EXEC");
}
